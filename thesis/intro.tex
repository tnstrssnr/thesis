\chapter{Introduction}\label{sec:intro}

\section{Motivation}

In February 2017, the American web services and web security company Cloudflare made headlines, when a security bug was discovered in an HTML parser. A buffer overrun caused the servers to leak sensitive data, such as browser cookies, authentication tokens or HTTP post bodies. The so-called `Cloudbleed' bug is one of many examples of software revealing secret data to unauthorized users, a security threat that has become more severe, as more and more software is used in the handling of sensitive data \cite{cloudbleedIssue, cloudbleedReport}. 

Qualitative information flow control aims to guarantee, that a program's public outputs are not influenced by secret its secret inputs, thus a malicious attacker has no possibility of obtaining secret information, by merely observing the program's outputs. This property is called \emph{non-interference}. 

For non-interferent programs, the secret inputs are guaranteed to have no influece on the public outputs, so unintentional data leaks are impossible. However, often this requirement is too strict for practical use. Consider the program shown in figure \ref{fig:pwChecker}. While the secret password is not leaked in its entirety, an attacker can gather some information by observing whether their guess was correct. Hence, non-interference is not given, however for most practical purposes, the information leakage from the password checker example would be fully acceptable and often also inevitable for the program's intended usage.

The desire to make information flow control applicable to more practical applications gave rise to the notion of quantitative information flow control (QIFC), where the amount of leakage in a program is measured in bits and compared to a predetermined limit. The amount of leakage in the password checker example is one bit.

\note{Difference: IF control vs IF security}

\begin{figure}
\centering
\begin{minipage}{.7\linewidth}
    \begin{algorithm}[H]
        \begin{algorithmic}[1]
    \Procedure{check_password}{guess: int}
            \If{$guess == password$}
                \State $match \leftarrow 1$
            \Else
                \State $match \leftarrow 0$
            \EndIf\\
            \Return match
            \EndProcedure
    \end{algorithmic} 
    \end{algorithm}
    \end{minipage}
    \caption{Password Checker}
    \label{fig:pwChecker}
\end{figure}

QIFC analyses can typically be divided into 2 categories: \emph{Static} analyses are performed without executing the program and rely solely on examination of the source code. Such analyses are sound in that they deliver an upper bound for the amount of information a program might leak. However, depending on the program, the upper bound the analysis is able to compute might be much larger than the actual leakage, due to the lack of knowledge about concrete control and data flows in the program. Contrarily, \emph{dynamic} analyses compute a program's leakage by simulating one or more program executions. For these executions, dynamic analyses can compute a more precise estimation of the leakage than static analyses, however these estimations might not be a sound upper bound, since it is infeasible to analyse every possible input combination for the program.

Many modern dynamic QIF analyses are based on symbolic execution and SAT solving techniques (see \ref{sec:relWork}). These naturally suffer the same difficulties as the underlying program analysis tools themselves, primarily dealing with path explosion and propositional formulas that are too big to handle for state-of-the-art SAT solvers. This thesis introduces a model counting-based dynamic QIFC analysis, that is combined with a static analysis to overcome the problems that similar dynamic approaches exhibit. 

\section{Related Work}\label{sec:relWork}

While early mentions of quantifying information flow have been made, for example by Denning \cite{denning82}, a formal definition and theoretical groundwork for the QIF problem are given more recently by Lowe \cite{lowe02} and Smith \cite{smith09}.

QIFC analyses based on model counting have previously been introduced by several people.
Newsome, McCamant and Song \cite{newsome09} transform their programs into boolean predicates that accurately models its semantics. Using SAT techniques they then measure the program's channel capacity. The results are used to find false positives in a dynamic taint analysis in order to more accurately determine the amount of influence of an attacker over the program.

Klebanov, Manthey and Muise (\cite{klebanov13}) use the bounded model checking tool CBMC (\cite{cbmc}) to generate a boolean predicate and the d-DNNF-based \#SAT tools \textsc{sharp}SAT (\cite{thurley06}) and \textsc{DSHARP} (\cite{muise12}).

A similiar approach is used by Biondi et. al. in \cite{biondi18}. They also use CBMC to create a SAT formula. In order to address scalability issues with overly complex SAT formulas, they are the first use an approximate model counter, in this case ApproxMC (\cite{chakraborty13}).

Chu and Hashimoto in \cite{chu19} also combine the CBMC framework with an approximate model counter, however they do not measure channel capacity as the previously mentioned works did, instead they estimate the pre-image size of a certain program output.

In many of these works, there have been attempts to mitigate the problems that are caused by path explosion in input programs and the computational limits of state of the art model counters. These attempts include using approximate model counting instead of a precise calculation (\cite{biondi18, chu19}) or transformations of SAT formulas into easier to handle representations (\cite{klebanov13}). We have not yet seen an attempt to use static (Q)IFC techniques to reduce complexity at the time of formula creation. \com{Abschnitt iwie komisch so mittendrin}

% combined
A previous attempt at combining static and dynamic techniques has been made by McCamant and Ernst (\cite{mccamant08}). They transform programs into network graphs with edge capacities corresponding to the amount of Information that might flow between the corresponding program parts. Thus, the maximum leak of information corresponds to the maximum flow in the created network. 

% hybrid monitors in quallitative IFC?
% static methods?