\chapter{Design and Implementation}\label{sec:impl}

The following chapter will break down the analysis techniques used in the interpreter to estimate the information leakage for the current run of the program. We will explain the basic principles of the analysis, before going into further detail of handling more complex control flow structures. Lastly we will present the integration of the control flow analysis with the interpreter and how the analysis was implemented.

% input program:
% - javac --> bytecode
% working on CFG + SSA form

\section{Input Programs and Program Representation}

Input programs are written in a variant of the \texttt{while}-language with Java-like syntax. To introduce the basic principle of our analysis, we temporarily restrict the scope of the input language to the grammar shown in figure \ref{fig:whileSyntax}. We will denote secret inputs as $h_i$, constant values as $n_i$ and other program variables as $x_i$. The set of all input variables for a program will be denoted as \In and the set of all possible input sets is written as \allIn.

Semantically, we interpret programs per the standard semantics of the input language. The special function \texttt{print} $x$ leaks the value $x$ to a public output channel. All programs p are deterministic, which means for every \In $\in$ \allIn, there is a unique program execution, which we will call $p_\mIn$. Furthermore we assume that all program executions terminate normally, without throwing an exception.

\begin{comment}
   \begin{itemize}        
        \item \question{Wie werden Eingabeparameter in Grammatiken angegeben?}
        \item \question{""Standard semantics""?}
        \item \question{`High level' Sprache oder Instructions, die in CFG verwendet werden? (Phi in Grammatik?)}
        \item \note{`Erklärung' statt Grammatik zur Definition der Eingabesprache}
        \item \note{Refer to: Clark+Hunt `Quantified Interference for a While Language'}
    \end{itemize}
    
    \begin{figure}
        \centering
        \begin{grammar}
            <program> ::= `in:' $[h]^*$ `;' <command>
            
            <command> ::= <command> `;' <command>
            \alt $x$ `:=' <arithmeticExpr>
            \alt $x$ `:= \phi(x_i, x_j)'
            \alt `if' <booleanPredicate> `do' <command> `else' <command>
            \alt `print' $x$
            \alt `skip'
            
            <arithmeticExpr> ::= $x$
            \alt $n$
            \alt <arithmeticExpr> <\oplus> <arithmeticExpr>
            \alt `-'<arithmeticExpr>
            
            <\oplus> ::= `+'
            | `-'
            | `*'
            | `/'
            | `&'
            | `|'
            | `^'
            
            <booleanPredicate> ::= `true'
            \alt `false'
            \alt `\neg' <booleanPredicate>
            \alt <booleanPredicate> <\circledcirc> <booleanPredicate>
            \alt <arithmeticExpr> <\otimes> <arithmeticExpr>
            
            <\otimes> ::= `==' | `!=' | `\leq' | `\geq'
            
            <\circledcirc> ::= `&&' | `||'
        \end{grammar}
        \caption{Grammar for the restricted input language used to explain the basic analysis principles. Programs are interpreted according to the standard semantics of the language features.}
        \label{fig:whileSyntax}
    \end{figure}
\end{comment}
   

% TODO: data type --> int, fixed width

To analyse out input program \p, we use the control flow graph (CFG) of its static single assignment (SSA) form. The nodes of a CFG are the programs basic blocks \question{Capital?} and an edge is inserted for every possible jump from one block to another. We use $\mbb_p$ for the set of all basic blocks of a program \p and $b_1, b_2, ...$ for the blocks themselves.

\begin{itemize}
    \item \note{Assume CFG has no critical edges (can be eliminated by splitting the edge w/ an empty basic block)}
    \item \note{every bock has at least 1 predecessor and 1 successor}
    \begin{itemize}
        \item \note{Exception: start block (no predecessors) and exit block (no successors)}
    \end{itemize}
    \item \com{function for succs and preds}
\end{itemize}

In SSA form, every value of the program is assigned exactly once. We write \val$_p$ to denote the set of all values of a program and $v_0, v_1, ...$ to denote single values. Each value is associated with its value dependencies and an execution value.

\begin{itemize}
    \item \note{execution values: represent actual value during execution}
    \item \note{represented as bit vectors (two's complement}
    \begin{itemize}
        \item integers: width n
        \item booleans: width 1
    \end{itemize}
    \item \com{specify relationship between valueDeps and execVal}
\end{itemize}

\begin{definition}[Execution Value]
The function maps a program value to the number that was assigned during a particular execution. If in this execution, the value remains undefined, because the corresponding assignment instruction wasn't executed, the function will return $\bot$.
    \begin{center}
        $exec_{\mI, p}: \val_p \longrightarrow \{0, 1\}^n \cup \{\bot\}$
    \end{center}
The function is parameterized by the input \p and the set of program inputs \I, which determine the particular execution of \p that is evaluated.
\end{definition}

\begin{definition}[Value Dependencies]

    
\end{definition}

\section{Basic Analysis Design}

\begin{itemize}
    \item \note{approach: symbolic execution}
    \item \note{data + cf dependencies represented as boolean formulas}
    \item \com{define set of boolean formulas, \ttt, \fff, operators etc.}
\end{itemize}

We use propositional logic to track the way that information about the secret inputs flows through the program. Each program value is interpreted as a bit vector, where each bit is associated with a propositional formula that encodes how the state of the bit is dependent on the secret inputs. We will use subscript indices to access the i-th bit of a program value or the i-th element of a vector respectively. The bitwidth of a value \texttt{x} will be denoted as $width(\mathtt{x})$.

\begin{definition}[Independent Set]
    Let \texttt{H} be the set of input values of \pp.
    \begin{center}
        $\var_p := \bigcup\limits_{\mathtt{h} \in \mathtt{H}} \{h^j | 0 \leq j \leq width(\mathtt{h})\}$
    \end{center}
    The values of a program's input parameters are not dependent on any other value in the program. We define the set $\var_p$, that contains a propositional variable for each input bit. Every other value of \p is either constant or can be described by a propositional formula over $\var_p$.
\end{definition}

\textbf{\note{Implicit information flow (CF dependencies)}}

\begin{itemize}
    \item \note{Associate each block w/ a boolean formula that evaluates to true <==> block is executed in the specific execution}
    \item \note{a block is executed iff one of its predecessors is executed and if the jump comdition from that predecessors evaluates to true}
    \item \com{Function for accessing condition of a conditional kump at the end of block -->} \question{necessary?}
    \item \question{`Abbildungsvorschrift' nötig?}
    \item \com{imDep: bblock -> formula -- f === wahr <--> b wird ausgeführt}
\end{itemize}

% define implicit leakages
\paragraph{Implicit Information Flow}

% TODO: better description for the case conditions
% TODO: check if this is even correct lol
% TODO: is knowledge the right word to use here?
% TODO: find better name for function than Phi

\paragraph{Explicit Knowledge Function}

% map + semantics for finding implicit leakage

\section{Handling Loops, Recursion and Function calls}

\section{Integration with Interpreter}

\section{Implementation}