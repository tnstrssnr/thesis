\chapter{Design and Implementation}\label{sec:impl}

The following chapter will break down the analysis techniques used in the interpreter to estimate the information leakage for the current run of the program. We will explain the basic principles of the analysis, before going into further detail of handling more complex control flow structures. Lastly we will present the integration of the control flow analysis with the interpreter and how the analysis was implemented.

% input program:
% - javac --> bytecode
% working on CFG + SSA form

\section{Program Syntax and Representation}

% TODO: where to put this part?
Input programs are written in Java, however we only allow a subset of Java's features to be used. Effectively our input language is a variant of the \texttt{while}-language. We use the special function \texttt{print} $x$ to leak the value $x$ to a public output channel. Figure \ref{fig:while_syntax} shows the scope of language features using a simplified syntax. 

% TODO: syntax --> grammar ??
% TODO: data type --> int, fixed width

To analyse out input program \p, we use the control flow graph (CFG) of its static single assignment (SSA) form. In SSA form, every value of the program is assigned exactly once. We write \val$_p$ to denote the set of all values of a program.

For each program \pp, we define $\bb_p$ as the set of basic blocks of \pp. We use the functions $succ(\cdot), pred(\cdot): \bb_p \longrightarrow 2^{\bb_p}$ to respectively get the successors or predecessors of a basic block. The nodes of the CFG $G = (V, E)$ of \p are $V = \bb_p \cup \{\mathtt{start}, \mathtt{end}\}$. 

% TODO: explain start and end node
% TODO: same name for function and set ?!

\begin{definition}[Def-Basic Block Map]
    A function that maps a program value to the basic block, where it is defined. Because all our input programs are in SSA form, this function is well-defined.
    \begin{center}
        $bb_p\colon: $\val$ \longrightarrow \bb_p$
    \end{center} 
\end{definition}

\begin{definition}[Immediate dominator] The immediate dominator of a basic block $b$ is the basic block $b'$ that strictly dominates $b$ and that is simultaneously dominated by every strict dominator of $b$.
    \begin{center}
        $idom\colon \mbb_p \longrightarrow \mbb_p$
    \end{center}
\end{definition}

\section{Basic Analysis Design}

We use propositional logic to track the way that information about the secret inputs flows through the program. Each program value is interpreted as a bit vector, where each bit is associated with a propositional formula that encodes how the state of the bit is dependent on the secret inputs. We will use subscript indices to access the i-th bit of a program value or the i-th element of a vector respectively. The bitwidth of a value \texttt{x} will be denoted as $width(\mathtt{x})$.

\begin{definition}[Independent Set]
    Let \texttt{H} be the set of input values of \pp.
    \begin{center}
        $\var_p := \bigcup\limits_{\mathtt{h} \in \mathtt{H}} \{h^j | 0 \leq j \leq width(\mathtt{h})\}$
    \end{center}
    The values of a program's input parameters are not dependent on any other value in the program. We define the set $\var_p$, that contains a propositional variable for each input bit. Every other value of \p is either constant or can be described by a propositional formula over $\var_p$.
\end{definition}

We will write $\mbform_{\var_p}$ for the set of all propositional formulas over $var_p$.

\begin{definition}[Input dependency map]
    For each bit $\mathtt{x}_i$, $\depvec{x}_i$ describes its dependencies to the programs input parameters, i.e. for an execution with input values \In, it holds that $\mathtt{x}_i == 1 \iff \depvec{x}_i == \mttt$ for $0 \leq i < width(\mathtt{x})$
    \begin{center}
        $\llbracket \cdot \rrbracket\colon \val_p \longrightarrow \mbform_{\var_p}^{width(mathtt{x})}$
    \end{center}
\end{definition}

To represent integer arithmetic as propositional formulas, we use two's complement representation of integers.

\begin{definition}[Two's complement]
    A function that for a given integer $n$ returns a vector of boolean constants that corresponds to the two's complement of $n$, where $0$ is represented by the value \fff and $1$ is represented by the value \ttt.
    \begin{center}
        $tcmp_l\colon: \mathbb{Z} \longrightarrow \{ \mttt, \mfff \}^l$
    \end{center}
    The map $tcmp_l$ is parameterized by the length $l$ of the return vector. If an integer $n$ requires $k > l$ bit to be correctly represented as a two's complement bit vector, $tcml$ will cut off the first $k - l$ bits and return the remaining vector.
\end{definition}

We extend the arithmetic operators of our input language to also operate on propositional formula vectors, treating them as two's complement integers and returning the result as a propositional formula vector of the same length. For a more in-depth explanation, we refer to \cite{}.
% TODO: citation
% TODO: arithmetic on twos complement numbers --> how detailed should this be? 
% TODO: same w/ bitwose operators
\begin{figure}
    \label{fig:input_deps_computation}
    \centering
    \begin{gather*}
        \inference[In]{\mathtt{h} \in \mathtt{H}}{\depvec{h} = (h^1, ... h^k)} \hspace{1cm}
        \inference[Const]{n \in \text{\textsc{Const}}_p}{\depvec{n} = tcmp(n)} \\ \vspace{1cm}
        \inference[BinArith]{\mathtt{x := y} \oplus \mathtt{z} & \depvec{y} = y & \depvec{z} = z & \oplus \in \{+, -, \cdot, \div\}}{\depvec{x} = y \oplus_{tcmp} z} \\ \vspace{1cm}
        \inference[BinBitwise]{\mathtt{x := y} \otimes \mathtt{z} & \depvec{y} = y & \depvec{z} = z & \otimes \in \{\text{\&}, |, \XOR \}}{\depvec{x} = y \otimes_{tcmp} z}
    \end{gather*}
        
\end{figure}

% TODO: define width(int) = k
% TODO: unary operations
% TODO: Expressions

\begin{definition}[Jump condition] The function $JumpCond$ takes two basic blocks $b_1$ and $b_2$, where $b_1 \in preds(b_2)$ and returns a boolean formula that describes under which condition the program execution will jump from $b_1$ to $b_2$. If the jump instruction is unconditional, then $JmpCond$ will simply return \ttt.
    \begin{center}
        $JmpCond\colon \mbb_p \times \mbb_p \longrightarrow \mbform$
    \end{center}
\end{definition}
An example evaluation of this function is shown in figure \ref{fig:jmp_cond}.

\begin{figure}[H]
    \label{fig:jmp_cond}
    \centering
    \begin{tikzpicture}[
                > = stealth, % arrow head style
                shorten > = 1pt, % don't touch arrow head to node
                auto,
                node distance = 3cm, % distance between nodes
                semithick % line style
            ]

            \node[rectangle, draw, align=center, minimum width=2.5cm, minimum height=1cm] (0) {$b_0$};
            \node[rectangle, draw, align=center, minimum width=2.5cm, minimum height=1cm] (s) [below of=0] {$b_1$ \\... \\ \bigskip \texttt{jmp} \textit{e} \texttt{?} $b_2$ \texttt{:} $b_3$};
            \node[rectangle, draw, align=center, minimum width=2cm, minimum height=1cm, xshift=-2cm] (v1) [below left of=s] {$b_2$};
            \node[rectangle, draw, align=center, minimum width=2cm, minimum height=1cm, xshift=2cm] (v2) [below right of=s] {$b_3$};

            \path[->] (0) edge (s);
            \path[->] (s) edge (v1);
            \path[->] (s) edge (v2);
    \end{tikzpicture}
    \caption{An exemplary control flow graph to demonstrate the $JmpCond$ function. The function returns $JmpCond(b_0, b_1) = \mttt, JmpCond(b_1, b_2) = e$ and $JmpCond(b_1, b_3) = \neg e$}
    % TODO: better caption
\end{figure}

% define implicit leakages
\paragraph{Implicit Information Flow}
Information flow is called \emph{implicit}, if is not the result of a direct assignment of secret values to public variables, but rather the flow of execution in the program that is dependent on secret values.

% TODO: Satz ist ziemlich unverst√§ndlich

\begin{definition}[Implicit Knowledge Function] 
    \begin{center}
        $\Phi\colon \mbb_p \longrightarrow \mbform$ \\
        \begin{equation*}
            b \mapsto
        \begin{cases}
            \mttt & b = \mathtt{start} \\
            \Phi(idom(b)) \land e & \parbox[t]{.6\textwidth}{$idom(b) \in pred(b) \land JmpCond(idom(b), b) = e$}\\ 
            \Phi(idom(b)) & \text{otherwise}\\ 
        \end{cases}
        \end{equation*}
    \end{center}
    The implicit knowledge-function maps a basic block $b \in \mbb_p$ of the input program \p to a boolean formula $f \in \mbform$ that describes the conditions that must be fulfilled by the program's values, if the $b$ is executed.
\end{definition}


% TODO: better description for the case conditions
% TODO: check if this is even correct lol
% TODO: is knowledge the right word to use here?
% TODO: find better name for function than Phi

\paragraph{Explicit Knowledge Function}

% map + semantics for finding implicit leakage

\section{Handling Loops, Recursion and Function calls}

\section{Integration with Interpreter}

\section{Implementation}